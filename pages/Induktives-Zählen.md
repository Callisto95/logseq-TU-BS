- Wir wollen die Zahl $R\left(i\right)=\left|\lbrace v\in V:\text{v in <= i Schritten von s erreichbar}\right|$ berechnen
- unter der Annahme, dass R(i-1) bekannt ist
	- dabei ist R(0)=1, da nur s selbst mit einem Pfad der Länge 0 erreichbar ist
	- R(n)=N, da jeder erreichbare Knoten auch mit einem einfachen Pfad (der insbesonderen Länge <= n hat) erreichbar ist
	- jeder Knoten v, der in i Schritten erreichbar ist, ist Nachfolger eines Knotens u, der in i-1 Schritten erreichbar ist
-
- Algorithmus \#reach(G,s)
  collapsed:: true
	- R(0)=1
	- für i=1,...,n do
		- R(i)=0
		- für alle Knoten v do
			- count=0
			- für alle Knoten u do
				- Rate, ob u von s aus in <= i-1 Schritten erreichbar ist
				- if Ja then
					- Rate einen Pfad von s nach u der Länge i-1
					- if Pfad ungültig then
						- return false
					- end if
					- count++
					- if u=v oder u->v then
						- R(i)++
						- break
					- end if
				- end if
			- end for u
			- if count != R(i-1)
				- return false
			- end if
		- end for v
	- end for i
	- return R(n)
-
- \#reach(G,s) berechnet für jede Zahl $i\in\left\lbrace0,...,n\right\rbrace$ korrekt $R\left(i\right)$
	- Beweis: Induktion
		- Basisfall i=0 ist klar
		- Wie zuvor liefert die Berechnung nur dann nicht false, wenn in jedem Durchlauf genau die erreichbaren Knoten u als erreichbar geraten wurden
		- Im Durchlauf für einen Knoten v erhöhen wie R(i) in so einer Berechnung genau dann um 1, wenn v wirklich erreichbar ist
		- Genau dann gibt es nämlich einen Vorgänger von v, der in i-1 Schritten erreichbar ist
-