- **L, NL**
	- Problem in L, wenn es deterministisch mit logaritmischen Platz lösen kann
	- [[Path-ist-in-NL]]
-
- [[2Sat-ist-NL-vollständig]]
- [[2-Färbbarkeit-in-Graphen-ist-in-L]]
-
- **Reduktion**
	- sei $A\subseteq\Sigma_1^{\ast}$ eine Sprache / Problem
	- A heißt *R-many-one redurzierbar* auf eine Sprache $B\subseteq\Sigma_2^{\ast}$, falls es eine Funktion $f:\Sigma_1^{\ast}\rightarrow\Sigma_2^{\ast}$ existiert
		- dabei gilt $\forall x\in\Sigma_1^{\ast}:x\in A\Leftrightarrow f\left(x\right)\in B$
	- f ist die Reduktion
	- Schreibweise: $A\leq_{m}^{R}B$
-
- **Schwere**
	- Sprache B heißt C-schwer (bezüglich R-many-one Reduktionen), falls sich alle $A\in C$ mit R-many-one-Reduktionen auf B reduzieren lassen
	- => $\forall A\in C:A\leq_{m}^{R}B$
- **Vollständigkeit**
	- Sprache B heißt C-Vollständig (bezüglich R-many-one-Reduktionen), falls
		- $B\in C$ (Membership, untere Schranke der Schwere)
		- B ist C schwer (bezüglich R-many-one-Reduktionen) (Hardness, obere Schranke der Schwere)
- => B ist mindestenz so schwer wie jedes Problem in C; B ist das schwerste Problem in C
-
- <<VL12::Logspace, Polytime Reduktionen>>
-
- ---
- Beweis:
	- seien $f:\Sigma_1^{\ast}\rightarrow\Sigma_2^{\ast},g:\Sigma_2^{\ast}\rightarrow\Sigma_3^{\ast}$ logspace-berechenbar
	- dann ist auch $g\circ f:\Sigma_1^{\ast}\rightarrow\Sigma_3^{\ast}$ eine logspace-berechenbare Funktion
		- Damit folgt aus $A\leq_{m}^{\log}B,B\leq_{m}^{\log}C$ auch $A\leq_{m}^{\log}C$
	- Es seien $M_{f},M_{g}$ TM's, welche jeweils f bzw. g mit logaritmischen Platz berechnen
	- *Idee*: berechne $f\left(x\right)$ durch Simulation von $M_{f}$, verwende danach $M_{g}$ auf eine Eingabe $f\left(x\right)$ zur Berechnung von $g\left(f\left(x\right)\right)$
	- *Problem*: Wir haben bei logspace-berechenbaren Funktionen nur den Platz auf den Arbeitsbändern beschränkt. Die Ausgabe von $M_{f}$ kann mehr als $O\left(\log n\right)$ Platz benötigen
	- *Lösung*: Berechne f(x) biweise on-Demand und verwende den Speicherplatz wieder
	- *Wichtig*
		- die Ausgabe f(x) ist höchstenz polynomiell groß
		  logseq.order-list-type:: number
		- jede Zelle von f(x) ist logspace-berechenbar
		  logseq.order-list-type:: number
	- *Behauptung*
		- 1. gilt
		- Eine Konfiguration von $M_{f}$ zur Eingabe x ist gegeben durch (Kontrollzustand, Eingabe x, Inhalt Arbeitsbänder, Inhalt Ausgabeband, Kopfposition auf allen Bändern)
	- *Beobachtungen*
		- Eingabeband ist read-only
		- Ausgabeband ist write-only und $M_{f}$ darf sein Verhalten nicht davon abhängig machen
	- Essentiell für eine Konfiguration ist der Inhalt der Arbeitsbänder mit logarithmischen Platzbedarf
		- d.h. es gibt Konstanten d', d'', sodass jedes Band maximal $d^{\prime}\log n+d^{\prime\prime}$ Zellen belegt
	- => es gibt $\left|\Gamma\right|$ viele Möglichkeiten für jede Zelle, also $\left|\Gamma\right|^{d^{\prime}\log n+d^{\prime\prime}}$ für jedes Band
	- => Maximal $\left|Q\right|\cdot k\cdot\left|\Gamma\right|^{d^{\prime}\log n+d^{\prime\prime}}\cdot n\cdot k\cdot\left(d^{\prime}\log n+d^{\prime\prime}\right)$ Konfigurationen
		- $\left|Q\right|,k,d^{\prime},d^{\prime\prime}$ Konstanten
		- $2^{\log\left|\Gamma\right|\cdot\left(d^{\prime}\log n+d^{\prime\prime}\right)}=\left(2^{d^{\prime}\log n}+2^{d^{\prime\prime}}\right)^{\log\left|\Gamma\right|}=\left(n^{d^{\prime}}\cdot2^{d^{\prime\prime}}\right)^{\log\left|\Gamma\right|}\in O\left(n^{d}\right)$
	- => $M_{f}$ hält nach polynomiell vielen Schritten
	- => $M_{f}$ kann maximal polynomiell viele Zeichen auf das Ausgabeband schreiben
	- ---
	- *Behauptung*
		- 2. gilt
		- Wir konstruieren eine Maschine $M_{i}$, welche die i-te Zelle $\left(f\left(x\right)\right)_{i}$ von f(x) berechnet
		- $M_{i}$ verhält sich zunächst wie $M_{f}$
		- Zusätzlich hält $M_{i}$ einen Zähler count, der initial mit Wert i belegt ist
		- Solange count>0, reduziere count jedes Mal, wenn $M_{f}$ eine Ausgabe schreiben möchte
-